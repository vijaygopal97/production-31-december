const fs = require('fs');
const path = require('path');

const MASTER_DATA_JSON = path.join(__dirname, '../data/acMasterData.json');
const ASSEMBLY_CONSTITUENCIES_JSON = path.join(__dirname, '../data/assemblyConstituencies.json');

// Cache for master data to avoid reading file multiple times
let masterDataCache = null;
let cacheTimestamp = null;
const CACHE_DURATION = 5 * 60 * 1000; // 5 minutes

/**
 * Convert Excel column letter to index (A=0, B=1, ..., Z=25, AA=26, etc.)
 */
const colLetterToIndex = (col) => {
  let result = 0;
  for (let i = 0; i < col.length; i++) {
    result = result * 26 + (col.charCodeAt(i) - 64);
  }
  return result - 1;
};

/**
 * Load master data from Excel file
 * @returns {Object} Object with AC data mapped by AC name
 */
const loadMasterData = () => {
  const now = Date.now();
  
  // Return cached data if still valid
  if (masterDataCache && cacheTimestamp && (now - cacheTimestamp) < CACHE_DURATION) {
    return masterDataCache;
  }
  
  try {
    // Read from JSON file generated by Python script
    if (!fs.existsSync(MASTER_DATA_JSON)) {
      throw new Error(`Master data JSON file not found: ${MASTER_DATA_JSON}. Please run generateACMasterData.py first.`);
    }
    
    const jsonData = fs.readFileSync(MASTER_DATA_JSON, 'utf8');
    const acDataMap = JSON.parse(jsonData);
    
    // Cache the data
    masterDataCache = acDataMap;
    cacheTimestamp = now;
    
    return acDataMap;
  } catch (error) {
    console.error('Error loading master data:', error);
    throw error;
  }
};

/**
 * Get MP and MLA names for an AC
 * @route GET /api/master-data/ac/:acName
 * @access Private
 */
exports.getACData = async (req, res) => {
  try {
    const { acName } = req.params;
    
    if (!acName) {
      return res.status(400).json({
        success: false,
        message: 'AC name is required'
      });
    }
    
    const masterData = loadMasterData();
    
    // Try exact match first
    let acData = masterData[acName];
    let matchedKey = acName;
    
    // If not found, try case-insensitive match
    if (!acData) {
      const acNameLower = acName.toLowerCase().trim();
      for (const [key, value] of Object.entries(masterData)) {
        if (key && key.toLowerCase().trim() === acNameLower) {
          acData = value;
          matchedKey = key;
          break;
        }
      }
    }
    
    // If still not found, try partial match
    if (!acData) {
      const acNameLower = acName.toLowerCase().trim();
      for (const [key, value] of Object.entries(masterData)) {
        if (key && (key.toLowerCase().includes(acNameLower) || acNameLower.includes(key.toLowerCase()))) {
          acData = value;
          matchedKey = key;
          break;
        }
      }
    }
    
    if (!acData) {
      return res.status(404).json({
        success: false,
        message: `AC "${acName}" not found in master data`,
        availableACs: Object.keys(masterData).slice(0, 10)
      });
    }
    
    res.status(200).json({
      success: true,
      data: {
        acName: matchedKey,
        mpName: acData.mpName,
        mlaName: acData.mlaName,
        hasByeElection: acData.hasByeElection || false
      }
    });
  } catch (error) {
    console.error('Error getting AC data:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to fetch AC data',
      error: error.message
    });
  }
};

/**
 * Get all Assembly Constituencies for a state
 * @route GET /api/master-data/acs/:state
 * @access Private
 */
exports.getAllACsForState = async (req, res) => {
  try {
    const { state } = req.params;
    
    if (!state) {
      return res.status(400).json({
        success: false,
        message: 'State name is required'
      });
    }
    
    // Load assembly constituencies data
    let assemblyConstituenciesData;
    try {
      if (!fs.existsSync(ASSEMBLY_CONSTITUENCIES_JSON)) {
        return res.status(404).json({
          success: false,
          message: 'Assembly constituencies data file not found'
        });
      }
      
      const jsonData = fs.readFileSync(ASSEMBLY_CONSTITUENCIES_JSON, 'utf8');
      assemblyConstituenciesData = JSON.parse(jsonData);
    } catch (error) {
      console.error('Error loading assembly constituencies data:', error);
      return res.status(500).json({
        success: false,
        message: 'Error loading assembly constituencies data',
        error: process.env.NODE_ENV === 'development' ? error.message : 'Internal server error'
      });
    }
    
    // Find the state (case-insensitive)
    const stateKey = Object.keys(assemblyConstituenciesData.states || {}).find(
      s => s.toLowerCase() === state.toLowerCase()
    );
    
    if (!stateKey || !assemblyConstituenciesData.states[stateKey]) {
      return res.status(404).json({
        success: false,
        message: `State "${state}" not found`
      });
    }
    
    const stateData = assemblyConstituenciesData.states[stateKey];
    const acs = stateData.assemblyConstituencies || [];
    
    // Format ACs with code and name for easy searching
    const formattedACs = acs.map((ac) => ({
      acCode: ac.acCode || '',
      acName: ac.acName || '',
      displayText: `${ac.acCode || ''} - ${ac.acName || ''}`.trim(),
      searchText: `${ac.acCode || ''} ${ac.acName || ''}`.toLowerCase()
    }));
    
    res.status(200).json({
      success: true,
      data: {
        state: stateKey,
        acs: formattedACs,
        count: formattedACs.length
      }
    });
  } catch (error) {
    console.error('Get all ACs for state error:', error);
    return res.status(500).json({
      success: false,
      message: 'Server error',
      error: process.env.NODE_ENV === 'development' ? error.message : 'Internal server error'
    });
  }
};
